---
layout: post
title:  "QFlowNet: Fast, Diverse, and Efficient Unitary Synthesis with Generative Flow Networks"
date:   2025-12-18 12:32 +0400
image:  QFlowNet-schematic.png
hide_header_image: true
tags:   Quantum Computing
---

Unitary Synthesis, the decomposition of a unitary matrix into a sequence of quantum gates, is a fundamental challenge in quantum compilation. 
Prevailing reinforcement learning (RL) approaches are often hampered by sparse reward signals, which necessitate complex reward shaping or long training times, and typically converge to a single policy, lacking solution diversity. 
In this work, we propose QFlowNet, a novel framework that learns efficiently from sparse signals by pairing a Generative Flow Network (GFlowNet) with Transformers. Our approach addresses two key challenges. 
First, the GFlowNet framework is fundamentally designed to learn a diverse policy that samples solutions proportional to their reward, overcoming the single-solution limitation of RL while offering faster inference than other generative models like diffusion. 
Second, the Transformers act as a powerful encoder, capturing the non-local structure of unitary matrices and compressing a high-dimensional state into a dense latent representation for the policy network. 
Our agent achieves an overall success rate of 99.7% on a 3-qubit benchmark (lengths 1-12) and discovers a diverse set of compact circuits, establishing QFlowNet as an efficient and diverse paradigm for unitary synthesis.

{% highlight text %}
Algorithm 1: QFlowNet Training Loop

Input: Forward and backward parameters θ_F1, θ_B1
       Any GFlowNet loss function L_TB
       (optional) Experience replay buffer B

For t = 1 to N_iters do
    1. Sample a batch of trajectories {τ_k(t)} from P_F(· | ·, θ_Ft)
    2. (optional) Update B with {τ_k(t)}
    3. Update backward policy:
       θ_B(t+1) = θ_Bt - γ_t * (1/K) * Σ ∇ L_TB(θ_Bt; τ_k(t))
    4. (optional) Resample a batch of trajectories {τ_k(t)} from B
    5. Update forward policy:
       θ_F(t+1) = θ_Ft - η_t * (1/K) * Σ ∇ L_TB(θ_Ft; τ_k(t), P_B(· | ·, θ_B(t+1)))
End For
{% endhighlight %}

[jekyll-docs]: https://inaekoo.github.io
[jekyll-gh]:   https://github.com/InaeKoo
